<div class="inside-scroll-ribbon">

	<div class="scroll-element" data-anchor="home" style="margin-bottom: 50px;">
		<div class="h-ribbon">
			<div class="inside-scroll-element">
				<div class="section-label">Computational Science and Engineering</div>
				<div class="logo-park">
					<img src="imgs/logo-uni-ulm.svg">
					<img src="imgs/logo-thu.svg">
				</div>
			</div>
		</div>

		<div class="inside-scroll-element">
			<div class="headline" style="margin-top: 280px;">
				<h1>Wie kann ein Computer</h1>
				<h1>eine Pandemie vorhersehen?</h1>
			</div>
		</div>
	</div>

	<div class="scroll-element full-screen" data-anchor="intro">

		<div class="inside-scroll-element">
			<div class="scroll-col two-cols">
				<div class="scroll-element-content intro">
					<p>
						Sie möchten IngenieurIn werden und Probleme in den Naturwissenschaften, der Medizin oder den Wirtschaftswissenschaften mit Hilfe von Mathematik und Informatik lösen? Dann sind Sie hier richtig. Denn genau dies wird im Studiengang Computational Science and Engineering (CSE) gemacht.
					</p>
					<p>
						In vielen Bereichen vernetzen sich die technische und die digitale Welt immer mehr. Um diese komplexen Strukturen überblicken zu können und da die Durchführung von analogen Experimenten oftmals zu teuer oder nicht möglich ist, entstehen innovative Produkte immer häufiger mit Hilfe ausgeklügelter Rechnersysteme, mathematischer Modellierung und Simulation.
					</p>
				</div>
			</div>
		</div>
	</div>

	<div class="scroll-element hidden" data-anchor="engineering" style="padding-bottom: 300px;">
		<div class="inside-scroll-element">
			<div class="scroll-col"></div>
			<div class="scroll-col"></div>
			<div class="scroll-col">
				<div class="scroll-element-content" data-scrollto="simulation">
					<div class="circle-wrapper"><div class="circle"></div></div>
					<div class="icon"><img src="imgs/icons/engineering.svg"></div>
					<div class="section-label">Ingenieur- und Naturwissenschaften</div>
					<div class="text-box">
						<p>
							Die Wissenschaft formuliert Modelle welche unsere Welt beschreiben. Um diese Formulierungen zu verstehen und einsetzen zu können, braucht es ein breites Wissen in Ingenieur- und Naturwissenschaften. So können auch interdisziplinäre Zusammenhänge erkannt und gelöst werden. 
						</p>
						<div class="more">
							<svg width="80" height="25">
								<path d="M79,0.75 L40,24.25 L1,0.75" fill="transparent" stroke="#000000" stroke-width="1"/>
							</svg><br>
							mehr erfahren
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<div class="scroll-element hidden" data-anchor="mathematics" style="padding-bottom: 300px;">
		<div class="inside-scroll-element">
			<div class="scroll-col">
				<div class="scroll-element-content" data-scrollto="SIR">
					<div class="circle-wrapper"><div class="circle"></div></div>
					<div class="icon"><img src="imgs/icons/math.svg"></div>
					<div class="line"></div>

					<div class="section-label">Mathematik</div>
					<div class="text-box">
						<p>
							Fundierte Grundlagen in der Mathematik sind notwendig um die komplexen Berechnungen aus Industrie und Wissenschaft zu verstehen. Zusätzlich wird Kompetenz in der Numerik benötigt, um die Rechnungen exakt durchführen zu können.
						</p>
						<div class="more">
							<svg width="80" height="25">
								<path d="M79,0.75 L40,24.25 L1,0.75" fill="transparent" stroke="#000000" stroke-width="1"/>
							</svg><br>
							mehr erfahren
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	<div class="scroll-element hidden" data-anchor="computer-science" style="padding-bottom: 300px;">
		<div class="inside-scroll-element">
			<div class="scroll-col"></div>
			<div class="scroll-col">
				<div class="scroll-element-content" data-scrollto="cell-auto">
					<div class="circle-wrapper"><div class="circle"></div></div>
					<div class="icon"><img src="imgs/icons/computer.svg" width="35"></div>
					<div class="line"></div>

					<div class="section-label">Informatik</div>
					<div class="text-box">
						<p>
							Sei es für nummerische Simulationen oder zur Analyse enormer Datenmengen, Computer sind für die Berechnung technischer oder wissenschaftlicher Probleme nicht mehr wegzudenken. Daher wird die Fähigkeit gebraucht, Computer mittels Code effizient einsetzen zu können.
						</p>
						<div class="more">
							<svg width="80" height="25">
								<path d="M79,0.75 L40,24.25 L1,0.75" fill="transparent" stroke="#000000" stroke-width="1"/>
							</svg><br>
							mehr erfahren
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>
	

	<div class="scroll-element footer-anchor full-screen" data-anchor="footer" style="padding-bottom: 300px;">
		<div class="inside-scroll-element">
			<div class="scroll-col engineering"></div>
			<div class="scroll-col mathematics"></div>
			<div class="scroll-col computer-science"></div>
		</div>
	</div>

	<div class="scroll-element push-next" data-anchor="simulation">
		<div class="inside-scroll-element">

			<div class="scroll-col"></div>

			<div class="scroll-col">
				<h2>Rette Baden-Württemberg vor einer Pandemie!</h2>
				<!--
				<div class="scroll-element-content">
					<p>
						Damit ein Model nicht nur virtuell bleibt, wird es durch reale Daten validiert. Dabei sind die Modellparameter wie die Infektions- oder Genesungswahrscheinlichkeit Eigenschaften der zu untersuchenden Krankheit. Diese werden aber nicht als Wahrscheinlichkeiten definiert sondern folgende Kennzahlen sind üblich:
					</p>
				</div>
				-->
				<div class="scroll-element-content">
					<p>
						Eine hoch infektiöse Krankheit bedroht das Bundesland Baden-Württemberg! Als Maßnahme gegen die drohende Epidemie plant die Landesregierung das Abriegeln der Regierungsbezirke Tübingen, Freiburg, Karlsruhe oder Stuttgart durch einen Lockdown. Um die während des Lockdown verhängten Freiheitseinschränkungen für die Bevölkerung zu minimieren, wird das Szenario simuliert. Modellparameter sind die spezifischen Krankheitsparameter wie Basisreproduktionszahl, Inkubationszeit und Genesungszeit. Zusätzlich muss eine Ober- sowie Untergrenze für den Lockdown durch die Landesregierung bestimmt werden.
					</p>
					<p>
						Hier ist deine Hilfe gefragt: Verstelle durch die Regler auf der linken Seite die Ober- sowie Untergrenze für einen Lockdown und starte die Simulation mit unterschiedlichen Werten. Durch die Diagramme wird ersichtlich wie viel Prozent der Bevölkerung mit der Krankheit infiziert werden. Schaffst du es, die Kurven abzuflachen um eine Überbelegung der Krankenhäuser zu vermeiden?

						<!-- und ob das Maximum der vorhandenen Pflegestationen überschritten wurde. Ist es möglich die Kurve so weit abzuflachen, dass für alle schweren Verläufe der Krankheit jederzeit eine Pflegestation vorhanden ist? -->
					</p>
				</div>
			</div>

			<div class="scroll-col">
				<h2 class="hidden">&nbsp;<br>&nbsp;<br>&nbsp;</h2>
				<div class="scroll-element-content gray">
					<h3>Epidemie und Pandemie</h3>
					<p>
						Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
					</p>

					<h3>Das Virus</h3>
					<p>
						Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum.
					</p>

					<h3>Die Basisreproduktionszahl <span class="formula">R<sub>0</sub></span></h3>
					<p>
						Die Basisreproduktionszahl gibt an wieviele Individuen ein Infizierter ansteckt, wenn noch kein Anteil der Population immun gegen die Krankheit ist.
					</p>

					<h3>Die Inkubationszeit</h3>
					<p>
						Dies ist die Zeit von der Ansteckung bis zu den ersten Symptomen und Ausbruch der Krankheit.
					</p>

					<h3>Die Genesungszeit</h3>
					<p>
						Die Zeit bis der Körper genügend Antikörper produziert hat um das Virus abzuwehren. Die Antikörper verhindern auch eine Neuansteckung und der Körper ist damit immun gegen die Krankheit.
					</p>
				</div>
			</div>
		</div>
	</div>


	<div class="scroll-element push-next" data-anchor="SIR">
		<div class="inside-scroll-element">

			<div class="scroll-col">
				<h2>Das SIR-Modell</h2>
				<div class="scroll-element-content">
					<p>
						Das SIR-Modell ist eine einfache Art eine Epidemie zu modellieren. Dabei wird eine Population in drei Gruppen unterteilt:
					</p>
					<ul>
						<li>die (noch) Gesunden (<strong>S</strong>usceptible)</li>
						<li>die Infizierten (<strong>I</strong>nfected)</li>
						<li>die Genesenen (<strong>R</strong>esistant) und Immunen</li>
					</ul>
					<p>
						Das Modell wird durch Differenzengleichungen definiert. Diese Gleichungen sind diskrete Rechenvorschriften, womit die Werte für den neuen Schritt <span class="formula">k+1</span> aus den Werten des aktuellen Schrittes <span class="formula">k</span> berechnet werden. Die berechneten Werte sind in diesem Falle der prozentuale Anteil der Population in den einzelnen Gruppen, beschrieben durch eine Zahl zwischen <span class="formula">o</span> und <span class="formula">1</span>. Für das SIR-Modell sehen die Differenzengleichungen wie folgt aus:
					</p>
					<table class="formula">
						<tr>
							<td>S<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>S<sub>k</sub></td>
							<td> &minus; &alpha;&#8729;S<sub>k</sub>&#8729;I<sub>k</sub></td>
						</tr>
						<tr>
							<td>I<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>I<sub>k</sub></td>
							<td>+ &alpha;&#8729;S<sub>k</sub>&#8729;I<sub>k</sub></td>
							<td> &minus; &beta;&#8729;I<sub>k</sub></td>
						</tr>
						<tr>
							<td>R<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>R<sub>k</sub></td>
							<td></td>
							<td>+ &beta;&#8729;I<sub>k</sub></td>
						</tr>
					</table>
					<p>
						Dabei sind <span class="formula">&alpha;</span> und <span class="formula">&beta;</span> konstante Modellparameter. Diese unterscheiden sich von Epidemie zu Epidemie und beschreiben spezifische Eigenschaften des Virus, der Krankheit oder auch der Population. In diesem einfachen Fall sind das:
					</p>
					<h3>Die Infektionsrate <span class="formula">&alpha;</span></h3>
					<p>
						Trifft jeder Gesunde auf jeden Infizierten, so sind dies <span class="formula">S<sub>k</sub>&#8729;I<sub>k</sub></span> Kontakte. Wenn bei all diesen Kontakten prozentual <span class="formula">&alpha;</span> Infektionen geschehen, so gibt es <span class="formula">&alpha;&#8729;S<sub>k</sub>&#8729;I<sub>k</sub></span> Neuinfektionen pro Zeitschritt.
					</p>
					<h3>Die Genesungsrate <span class="formula">&beta;</span></h3>
					<p>
						In jedem Zeitschritt genesen prozentual <span class="formula">&beta;</span> Infizierte, also werden in jedem Zeitschritt <span class="formula">&beta;&#8729;I<sub>k</sub></span> Infizierte gesund und damit immun.
					</p>
				</div>
			</div>

			<div class="scroll-col"></div>

			<div class="scroll-col">
				<h2 class="hidden">&nbsp;</h2>
				<div class="scroll-element-content gray">
					<h3>Der Unterschied zu Differentialgleichungen</h3>
					<p>
						Das SIR-Modell &ndash; oder auch andere mathematische Modelle &ndash; sind oftmals durch ein Differential&shy;gleichungs&shy;system beschrieben. Dabei werden nicht diskrete Rechenschritte beschrieben, sondern die Ableitung einer stetigen Funktion.
					</p>

					<h3>Ein einfaches Beispiel</h3>
					<p>
						Sei die Anzahl der Infizierten über die Zeit <span class="formula">I(t)</span> nur von den bereits Infizierten und einer Konstanten <span class="formula">&lambda;</span> abhängig und sei die Ableitung wie folgt definiert:
					</p>
					<p class="formula">
						I'(t) = &lambda; &#8729; I(t)
					</p>
					<p>
						Diese Differentialgleichung hat für die Anfangswertbedingung <span class="formula">I(0) = I<sub>0</sub></span> die Lösung
					</p>
					<p class="formula">
						I(t) = I<sub>0</sub> &#8729; e<sup>&lambda;&#8729;t</sup>
					</p>
					<p>
						Die Funktion <span class="formula">I(t)</span> steigt also exponentiell an. Oft wird bei exponentiellem Wachstum die Verdoppelungs&shy;dauer <span class="formula">&#8710;t</span> angegeben, also die Dauer in dem sich die Infizierten verdoppeln. Damit kann <span class="formula">&lambda;</span> bestimmt werden:
					</p>
					<table class="formula">
						<tr><td width="30"></td><td class="right">
							2 &#8729; I(0)
						</td><td class="equals">=</td><td>
							I(&#8710;t)
						</td></tr>
						<tr><td>&hArr;</td><td class="right">
							2 &#8729; I<sub>0</sub>
						</td><td class="equals">=</td><td>
							I<sub>0</sub> &#8729; e<sup>&lambda;&#8729;t</sup>
						</td></tr>
						<tr><td>&hArr;</td><td class="right">
							2
						</td><td class="equals">=</td><td>
							e<sup>&lambda;&#8729;t</sup>
						</td></tr>
						<tr><td>&hArr;</td><td class="right">
							ln(2)
						</td><td class="equals">=</td><td>
							&lambda; &#8729; t
						</td></tr>
						<tr><td>&hArr;</td><td class="right">
							&lambda;
						</td><td class="equals">=</td><td>
							ln(2) / &#8710;t
						</td></tr>
					</table>
				</div>
			</div>

		</div>
	</div>


	<div class="scroll-element push-next" data-anchor="R0">
		<div class="inside-scroll-element">
			
			<div class="scroll-col">
				<div class="scroll-element-content">
					<h3>Die Basisreproduktionszahl <span class="formula">R<sub>0</sub></span></h3>
					<p>
						Die Basisreproduktionszahl gibt an, wieviele Individuen ein Infizierter ansteckt, wenn noch kein Anteil der Population immun gegen die Krankheit ist. Der Kehrwert davon, genauer <span class="formula">1 / R<sub>0</sub> = T<sub>R0</sub></span>, gibt an, wie lange es im Mittel dauert bis sich jemand Neues infiziert. Ist die Dauer bis zu einem neuen infektiösen Kontakt <span class="formula">T<sub>&alpha;</sub></span> sowie die Dauer bis zur Genesung <span class="formula">T<sub>&beta;</sub></span> bekannt, so kann damit die mittlere Dauer bis zur Neuinfektion berechnet werden:
					</p>
					<p class="formula">
						T<sub>R0</sub> = T<sub>&alpha;</sub> / T<sub>&beta;</sub>
					</p>
					<p>
						Weiter ist die Dauer bis zum infektiösen Kontakt gerade der Kehrwert der Infektionsrate <span class="formula">&alpha; = 1 / T<sub>&alpha;</sub></span> und die Genesungsdauer der Kehrwert der Genesungsrate <span class="formula">&beta; = 1 / T<sub>&beta;</sub></span>. Durch diesen Zusammenhang kann die Basisreproduktionszahl einfach durch die Infektionsrate und Genesungsrate berechnet werden:
					</p>
					<p class="formula">
						R<sub>0</sub> = &alpha; / &beta;
					</p>
					<p>
						Damit kann das Model eindeutig durch die zwei Parameter Basisreproduktionszahl <span class="formula">R<sub>0</sub></span> und mittlere Genesungsdauer <span class="formula">T<sub>&beta;</sub></span> bestimmt werden.
					</p>
				</div>
			</div>

		</div>
	</div>


	<div class="scroll-element push-next" data-anchor="SEIR">
		<div class="inside-scroll-element">
			
			<div class="scroll-col">
				<h2>Das SEIR-Modell</h2>
				<div class="scroll-element-content">
					<p>
						Einem viralen Infekt geht immer eine <strong>Inkubationszeit</strong> voraus. Dies ist die Zeit von der Infektion bis zum Ausbruch der ersten Krankheitssymptome. Um die Inkubationszeit im Modell zu berücksichtigen, muss es zu einem SEIR-Modell erweitert werden. Dabei wird die Gruppe der Infizierten in zwei Untergruppen unterteilt:
					</p>
					<ul>
						<li>
							ohne Symptome (<strong>E</strong>xposed)<br>
							Diese Gruppe befindet sich in der Inkubationszeit.
						</li>
						<li>
							mit Symptomen (<strong>I</strong>nfected)<br>
							Bei Individuen dieser Gruppe ist die Krankheit ausgebrochen.
						</li>
					</ul>
					<p>
						Hier wird davon ausgegangen, dass die Gruppe ohne Symptome genauso ansteckend ist wie die Gruppe mit Symptomen. Damit lauten die erweiterten Differenzengleichungen:
					</p>
					<table class="formula">
						<tr>
							<td>S<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>S<sub>k</sub></td>
							<td> &minus; &alpha; &#8729;S<sub>k</sub>&#8729;(E<sub>k</sub> + I<sub>k</sub>)</td>
						</tr>
						<tr>
							<td>E<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>E<sub>k</sub></td>
							<td> + &alpha; &#8729;S<sub>k</sub>&#8729;(E<sub>k</sub> + I<sub>k</sub>)</td>
							<td> &minus; &gamma;&#8729;E<sub>k</sub></td>
						</tr>
						<tr>
							<td>I<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>I<sub>k</sub></td>
							<td></td>
							<td> + &gamma;&#8729;E<sub>k</sub></td>
							<td> &minus; &beta;&#8729;I<sub>k</sub></td>
						</tr>
						<tr>
							<td>R<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>R<sub>k</sub></td>
							<td></td>
							<td></td>
							<td> + &beta;&#8729;I<sub>k</sub></td>
						</tr>
					</table>
				</div>
			</div>

		</div>
	</div>


	<div class="scroll-element push-next" data-anchor="calc-random">
		<div class="inside-scroll-element">
			
			<div class="scroll-col">
				<h2>Rechnen mit<br>dem Zufall</h2>
				<div class="scroll-element-content">
					<p>
						Die Differenzengleichungen rechnen jeweils mit der Gesamtanzahl der unterschiedlichen Gruppen. In einer weiteren Simulation mit einem zellulären Automaten werden nun einzelne Individuen betrachtet. In diesem Automaten werden <span class="formula">P</span> Individuen auf <span class="formula">N</span> Zellen verteilt. Dabei wird nicht mehr mit Raten, sondern mit Wahrscheinlichkeiten gerechnet.
					</p>
					<h3>Die Infektionswahrscheinlichkeit <span class="formula">a</span></h3>
					<p>
						Hat ein Individuum Kontakt mit einem Infizierten besteht die Wahrscheinlichkeit <span class="formula">a</span> sich zu infizieren.
					</p>
					<h3>Die Genesungswahrscheinlichkeit <span class="formula">b</span></h3>
					<p>
						Der Kehrwert <span class="formula">1/b</span> ist wieder die mittlere Zeit vom Ausbruch der Krankheit bis zur Genesung.
					</p>
					<h3>Die Ausbruchswahrscheinlichkeit <span class="formula">c</span></h3>
					<p>
						Der Kehrwert <span class="formula">1/c</span> ist die mittlere Inkubationszeit.
					</p>
					<p>
						Um die Differenzengleichungen mit dem Automaten und den Wahrscheinlichkeiten vergleichen zu können, muss eine äquivalente Form der Gleichungen hergeleitet werden. Dafür wird eine vereinfachte Form des Automaten verwendet. So werden die <span class="formula">P</span> Individuen in jedem Zeitschritt neu gleichverteilt auf die <span class="formula">N</span> Zellen aufgeteilt. Es werden also keinerlei geografische Eigenschaften wie Nachbarschaften ausgenutzt. Dabei ist auch die Größe einer Zelle nicht beschränkt und Infektionen geschehen jeweils nur innerhalb einer Zelle.
					</p>
					<p>
						Wie hoch ist nun die Wahrscheinlichkeit, dass sich ein Individuum innerhalb einer Zelle mit <span class="formula">C</span> Infizierten auch infiziert?
						Die Wahrscheinlichkeit, sich nicht zu infizieren ist <span class="formula">(1  &minus; a)</span>. Mit jedem weiteren Kontakt schwindet diese Wahrscheinlichkeit und wird erneut mit demselben Wert multipliziert (sofern der erste Kontakt unabhängig vom zweiten ist, siehe Box rechts). Also ist <span class="formula">(1  &minus; a)<sup>C</sup></span> die Wahrscheinlichkeit, sich bei <span class="formula">C</span> Kontakten nicht zu infizieren. Betrachtet man den Grenzwert
					</p>
					<p class="formula">
						lim<sub>C&rarr;&infin;</sub> (1  &minus; a)<sup>C</sup> = 0
					</p>
					<p>
						wird offensichtlich, dass bei unendlich vielen Kontakten mit Infizierten die Wahrscheinlichkeit, sich nicht zu infizieren, gleich 0 wird. Betrachtet man wiederum den Grenzwert der Negation, also die Wahrscheinlichkeit sich bei <span class="formula">C</span> Kontakten zu infizieren
					</p>
					<p class="formula">
						lim<sub>C&rarr;&infin;</sub>  1  &minus; (1 &minus; a)<sup>C</sup> = 1
					</p>
					<p>
						wird schnell klar, dass man sich irgendwann sicher infizieren wird.
					</p>
					<p>
						Nun ist im Automaten die durchschnittliche Anzahl an Infizierten pro Zelle (E+I)/N, also ist die Wahrscheinlichkeit für ein Individuum, sich zu infizieren
					</p>
					<p class="formula">
						1  &minus; (1 &minus; a)<sup>(E+I)/N</sup>
					</p>
					<p>
						Die Ausbruchswahrscheinlichkeit <span class="formula">c</span> ist über den Kehrwert der Inkubationszeit definiert und darum gilt <span class="formula">c = &gamma;</span>. Dasselbe gilt für die Genesungs&shy;wahr&shy;schein&shy;lich&shy;keit <span class="formula">b = &beta;</span>.
					</p>
					<p>
						Damit gilt für die Differenzengleichung mit Wahrscheinlichkeiten:
					</p>
					<table class="formula">
						<tr>
							<td>S<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>S<sub>k</sub></td>
							<td> &minus; S<sub>k</sub>&#8729;(1  &minus; (1 &minus; a)<sup>(E+I)/N</sup>)</td>
						</tr>
						<tr>
							<td>E<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>E<sub>k</sub></td>
							<td> + S<sub>k</sub>&#8729;(1  &minus; (1 &minus; a)<sup>(E+I)/N</sup>)</td>
							<td> &minus; c&#8729;E<sub>k</sub></td>
						</tr>
						<tr>
							<td>I<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>I<sub>k</sub></td>
							<td></td>
							<td> + c&#8729;E<sub>k</sub></td>
							<td> &minus; b&#8729;I<sub>k</sub></td>
						</tr>
						<tr>
							<td>R<sub>k+1</sub></td>
							<td class="equals">=</td>
							<td>R<sub>k</sub></td>
							<td></td>
							<td></td>
							<td> + b&#8729;I<sub>k</sub></td>
						</tr>
					</table>
				</div>
			</div>

			<div class="scroll-col"></div>


			<div class="scroll-col">
				<h2 class="hidden">&nbsp;<br>&nbsp;</h2>
				<div class="scroll-element-content gray">
					<h3>Der Münzwurf</h3>
					<p>
						Wie hoch ist die Wahrscheinlichkeit in zwei Würfen hintereinander zweimal einen Kopf zu werfen?
					</p>
					<p>
						Bei einem Wurf zeigt die Münze entweder Kopf oder Zahl. Nennen wir nun diese zwei möglichen Ausgänge aus dem Zufallsexperiment <span class="formula">1</span> (für Kopf) und <span class="formula">0</span> (für Zahl). Die Menge aller möglichen Ausgänge wird als Grundraum <span class="formula">&#8486;</span> bezeichnet. Für einen Wurf gilt
					</p>
					<p class="formula">
						&#8486; = {0,1}
					</p>
					<p>
						Das Ereignis einmal Kopf zu werfen wird durch die Teilmenge <span class="formula">A</span> von <span class="formula">&#8486;</span> definiert
					</p>
					<p class="formula">
						A = {1}
					</p>
					<p>
						Die Wahrscheinlichkeit, dass die Teilmenge <span class="formula">A</span> aus dem Grundraum <span class="formula">&#8486;</span> eintrifft wird durch das Wahrscheinlichkeitsmaß <span class="formula">P</span> bestimmt. Ist die Münze fair, so gilt
					</p>
					<p class="formula">
						P(A) = 0.5
					</p><p>
						Für zwei Münzwürfe enthält der Grundraum Vektoren mit je einem Eintrag für den ersten und zweiten Wurf:
					</p>
					<p class="formula">
						&#8486; = {(0,0),(0,1),(1,0),(1,1)}
					</p>
					<p>
						Die Menge <span class="formula">B</span> aller Ereignissen mit zwei Köpfen ist also
					</p>
					<p class="formula">
						B = {(1,1)}
					</p>
					<p>
						Bei einer fairen Münze ist die Wahrscheinlichkeit einfach zu bestimmen (dabei beschreibt <span class="formula">|X|</span> die Anzahl der Elemente der Menge <span class="formula">X</span>)
					</p>
					<p class="formula">
						P(B) = |B| / |&#8486;| = 1/4
					</p>
					<p>
						Was aber, wenn die Münze unfair ist und die Wahrscheinlichkeit für einen Kopf in einem Wurf <span class="formula">p</span> beträgt?
					</p>
					<p>
						Bei zwei Würfen ist die Menge der Ereignisse mit einem Kopf im ersten Wurf wie folgt
					</p>
					<p class="formula">
						A<sub>1</sub> = { {1} &times; {0,1} } = { (1,0), (1,1) }
					</p>
					<p>
						und für den zweiten Wurf gilt
					</p>
					<p class="formula">
						A<sub>2</sub> = { {0,1} &times; {1} } = { (0,1), (1,1) }
					</p>
					<p>
						Für diese Ereignisse gilt nach Aufgabenbeschreibung
					</p>
					<p class="formula">
						P(A<sub>1</sub>) = P(A<sub>2</sub>) = p
					</p>
					<p>
						Die Menge mit zwei Köpfen hintereinander kann nun als Schnitt dieser beiden Mengen beschrieben werden
					</p>
					<p class="formula">
						B = A<sub>1</sub> &xcap; A<sub>2</sub> = {(1,1)}
					</p>
					<p>
						und da der erste Wurf <strong>unabhängig</strong> vom zweiten ist, gilt für die Wahrscheinlichkeit von <span class="formula">B</span>
					</p>
					<p class="formula">
						P(B) = P(A<sub>1</sub> &xcap; A<sub>2</sub>) = P(A<sub>1</sub>) &#8729; P(A<sub>2</sub>) = p<sup>2</sup>
					</p>
				</div>
			</div>

		</div>
	</div>


	<div class="scroll-element push-next" data-anchor="cell-auto">
		<div class="inside-scroll-element">
			
			<div class="scroll-col">
				<h2>Der zelluläre Automat</h2>
				<div class="scroll-element-content">
					<p>
						Im Automaten werden einzelne Individuen in einer definierten Umgebung simuliert. Dabei ist die Umgebung in <span class="formula">n&times;m</span> sechseckige Zellen unterteilt. So hat jede Zelle sechs Nachbarzellen, dabei sind die Zellen am Rand jeweils mit dem gegenüberliegenden Randzellen verknüpft. Jede Zelle kann maximal sechs unterschiedliche Individuen enthalten. Ein Zyklus des Automaten ist in vier Teilschritte unterteilt. Dabei wird jeder Teilschritt für alle Individuen ausgeführt bevor der nächste Teilschritt folgt.
					</p>

					<h3>Bewegen</h3>
					<p>
						Die Individuen bewegen sich in jedem Schritt in ihre direkte Nachbarzelle fort:<br>
						<img src="imgs/cell_move.png" width="108">
					</p>
					<p>
						Mit Ausnahme der Infizierten bei welchen die Krankheit ausgebrochen ist. Diese sind durch die Krankheit bewegungsunfähig und bleiben stehen. Wird dadurch der Platz in einer Zelle für ein sich bewegendes Individuum besetzt, überspringt dieses die besetzte Zelle:<br>
						<img src="imgs/cell_jump.png" width="155">
					</p>

					<h3>Kollidieren</h3>
					<p>
						Enthält eine Zelle zwei oder mehr Individuen so werden diese zufällig im oder gegen den Uhrzeigersinn gedreht:<br>
						<img src="imgs/cell_rotate.png" width="156">
					</p>

					<h3>Infizieren</h3>
					<p>
						Befindet sich ein gesundes Individuum mit einem Infizierter mit oder ohne Symptomen in einer Zelle so besteht die Wahrscheinlichkeit, dass sich der Gesunde ansteckt:<br>
						<img src="imgs/cell_infect.png" width="155">
					</p>

					<h3>Gensen</h3>
					<p>
						Für jeden Infizierten ohne Symptome besteht in jedem Zeitschritt die Wahrscheinlichkeit, dass die Krankheit ausbricht. Für jeden Infizierten mit Symptomen wiederum besteht die Wahrscheinlichkeit auf Genesung:<br>
						<img src="imgs/cell_heal.png" width="249">
					</p>
				</div>
			</div>

			<div class="scroll-col">
				<h2 class="hidden">&nbsp;<br>&nbsp;</h2>
				<div class="scroll-element-content gray">
					<h3>Spiel des Lebens</h3>
					<p>
						Einer der bekanntesten zellulären Automaten ist das vom Mathematiker John Horton Conway entworfene Spiel des Lebens. Der Automat besteht aus wenigen einfachen Regeln, welche aber wiederum sehr komplexe Muster und Abläufe hervorbringen. So gibt es für bestimmte Zustände sich nach mehreren Schritten wiederholende Zyklen oder es gibt Strukturen, welche sich über längere Distanz als zusammenhängendes System fortbewegen.
					</p>
					<p>
						<div style="text-align: center">
							<img src="imgs/Gospers_glider_gun_gray.gif">
						</div>
						<span class="small">Quelle: <a href="https://de.wikipedia.org/wiki/Conways_Spiel_des_Lebens" target="_blank">Wikipedia, Conways Spiel des Lebens</a></span>
					</p>

					<p style="margin-bottom: 5px;">
						Die Regeln des Spieles können mit wenigen Sätzen beschrieben werden:
					</p>
					<p>
						Das Spielfeld besteht aus einem Gitterquadrat, in welchem jede Zelle acht Nachbarn besitzt. Eine Zelle kann zwei unterschiedliche Zustände annehmen: Tot oder lebendig. Eine tote Zelle wird neugeboren, wenn genau drei lebende Zellen angrenzen. Eine lebende Zelle bleibt am leben, wenn sie genau zwei oder drei lebende Nachbarn hat, ansonsten stirbt die lebende Zelle.
					</p>
				</div>
			</div>
		</div>
	</div>

	<div class="scroll-element push-next" data-anchor="implementation">
		<div class="inside-scroll-element">
			
			<div class="scroll-col">
				<h2>Implementation</h2>
				<div class="scroll-element-content">
					<p>
						Die Zellen des Automaten werden in einem Array <span class="code">cells</span> der Länge <span class="code">n*m</span> gespeichert.
						Wobei jede Zelle wiederum in sechs Sektoren unterteilt ist, worin jeweils ein Individuum enthalten sein kann. Also enthält jede Zelle wiederum ein Array der Länge <span class="code">6</span>.
					</p>
					<p>
						Damit hat jede Zelle einen eindeutigen Index <span class="code">k</span> und innerhalb der Zelle hat jeder Sektor einen eindeutigen Index <span class="code">l</span>.
						Dabei definiert der Index <span class="code">l</span> gerade auch die Position oder Ausrichtung des Individuums innerhalb einer Zelle.
					</p>
					<p>
						Durch die zwei Indizes <span class="code">k</span> und <span class="code">l</span> kann somit die Position jedes Individuums innerhalb des Automaten beschrieben werden. 
						 Ein Individuum sowie dessen Status wird nun durch einen entsprechenden Eintrag innerhalb des <span class="code">cells</span> Array repräsentiert.
					</p>
					<p class="code">
						cells[k][l] = 0 <span class="comment">// cell sector is empty</span><br>
						cells[k][l] = 1 <span class="comment">// susceptible</span><br>
						cells[k][l] = 2 <span class="comment">// exposed</span><br>
						cells[k][l] = 3 <span class="comment">// infected</span><br>
						cells[k][l] = 4 <span class="comment">// resistant</span><br>
					</p>

					<h3>Bewegen</h3>
					<p>
						Um zu vermeiden, das Einträge in dem <span class="code">cells</span> Array überschrieben werden, wird ein neues leeres Array <span class="code">newCells</span> von gleicher Länge angelegt.
					</p>
					<p>
						Zuerst werden die kranken Individuen an die exakt gleiche Stelle des neuen Arrays kopiert, denn diese bewegen sich ja nicht.
					</p>
					<p class="code">
						for k = 0 to n*m<br>
						   for l = 0 to 6<br>
						      if cells[k][l] is sick<br>
						         newCells[k][l] = cells[k][l]<br>
						      end<br>
						   end<br>
						end
					</p>
					<p>
						Danach werden alle anderen bewegt, wobei bereits durch kranke Individuen besetzte Stellen übersprungen werden. Die Funktionen <span class="code">moveOneStep(k,l)</span> berechnet zur Zelle mit Index <span class="code">k</span> die angrenzende nächste Zelle in Richtung <span class="code">l</span>.
					</p>
					<p class="code">
						for k = 0 to n*m<br>
						   for l = 0 to 6<br>
						      kNext = moveOneStep(k,l)<br>
						      while cells[kNext][l] is occupied<br>
						         kNext = moveOneStep(kNext,l)<br>
						      end<br>
						      newCells[kNext][l] = cells[k][l]<br>
						   end<br>
						end
					</p>
					<p>
						Zum Schluss wird die aktuelle Repräsentation der Zellen durch die Neue überschrieben.
					</p>
					<p class="code">
						cells = newCells
					</p>

					<h3>Kollidieren</h3>
					<p>
						Wiederum wird jede Zelle durchlaufen, dabei wird die Anzahl geprüft und sobal mehr als ein Individuum enthalten ist, werden diese gedreht.
					</p>
					<p class="code">
						for k = 0 to n*m<br>
						   if cells[k] has more <!--...<br>
						   &nbsp;&nbsp;&nbsp;&nbsp;...--> than 1 individual<br>
						      direction = 1 or -1 at random<br>
						      newSectors = empty Array<br>
						      for l = 0 to 6<br>
						         newL = (6+l+direction)%6<br>
						         newSectors[newL] = cells[k][l]<br>
						      end<br>
						      cells[k] = newSectors<br>
						   end</br>
						end
					</p>

					<h3>Infizieren und Genesen</h3>
					<p>
						Die zwei letzten Schritte werden gemeinsam in einer Schleife durchgeführt. Ob ein Individuum sich infiziert oder wieder genesen kann, wird durch Zufallszahlen zwischen <span class="code">0</span> und <span class="code">1</span> bestimmt.
					</p>
					<p class="code">
						for k = 0 to n*m<br>
						   for l = 0 to 6<br>
						      if cells[k][l] is susceptible<br>
						         for every infected inside cells[k]<br>
						            r = random number between 0,1<br>
						            if r < infection probability<br>
						               cells[k][l] becomes exposed<br>
						            end<br>
						         end<br>
						      end<br>
						   end<br>
						   <br>
						   for l = 0 to 6<br>
						      r = random number between 0,1<br>
						      if cells[k][l] is exposed<br>
						         if r < get sick probability<br>
						            cells[k][l] becomes infected<br>
						         end<br>
						      else if cells[k][l] is infected<br>
						         if r < recover probability<br>
						            cells[k][l] becomes recovered<br>
						         end<br>
						      end<br>
						   end<br>
						end
					</p>
				</div>
			</div>

			<div class="scroll-col">
				<h2 class="hidden">&nbsp;</h2>
				<div class="scroll-element-content gray">
					<h3>Kleines Pseudocode-Programmierer-Glossar</h3>
					<p>
						Programmcode wird oft als Pseudocode dokumentiert. Der dabei verwendete Syntax entspricht nicht einer spezifischen Programmiersprache, daher kann der Code so  nicht direkt von einer Maschine interpretiert werden. Er dient zur Beschreibung der Programmstruktur unabhängig der verwendeten Technologie und kann als Grundlage zur Implementation in jeder beliebigen Programmiersprache verwendet werden.
					</p>
					<table class="glossary">
						<tr>
							<td class="code">Array</td>
							<td>
								Eine einfache Datenstruktur in welcher Daten als eine Liste abgebildet werden. Jeder Listeneintrag enthält einen eindeutigen Index.
							</td>
						</tr>
						<tr>
							<td class="code">
								if
							</td>
							<td>
								Dadurch kann Code mittels einer Bedingung verzweigt werden. Ein Teil des Codes wird ausgeführt falls die Bedingung wahr ist, der <span class="code">else</span>-Teil wird ausgeführt falls die Bedingung nicht zutrifft.
							</td>
						</tr>
						<tr>
							<td class="code">
								for
							</td>
							<td>
								Die <span class="code">for</span>-Schleife wird genutzt um Code mehrfach auszuführen. Dabei wird ein Index kontinuierlich hochgezählt.
							</td>
						</tr>
						<tr>
							<td class="code">
								while
							</td>
							<td>
								Programmcode innerhalb der <span class="code">while</span>-Schleife wird solange die Bedingung wahr ist ausgeführt. 
							</td>
						</tr>
						<tr>
							<td class="code">
								%
							</td>
							<td>
								Der Modulo-Operator beschreibt eine Division mit Rest. So ist z.B. das Ergebnis von <span class="code">17%6</span> die Fünf, da <span class="formula">6 &#8729; 2 + 5 = 17</span> ist.
							</td>
						</tr>
					</table>
				</div>
			</div>

		</div>
	</div>

		
	

	<div class="scroll-element" data-anchor="the-end">
		<div class="black-ribbon">
			<div class="inside-scroll-element">
				<h2>Mehr erfahren und CSE studieren?</h2>
				<p>
					Informieren Sie sich auf der Webseite<br>
					der Technischen Hochschule Ulm:
				</p>
				<p>
					<a href="https://studium.hs-ulm.de/de/Seiten/Studiengang_CSE.aspx" target="_blank">
						https://studium.hs-ulm.de/de/Seiten/Studiengang_CSE.aspx
					</a>
				</p>
			</div>
		</div>
		<div class="white-ribbon">
			<div class="inside-scroll-element">
				<img src="imgs/logo-uni-ulm.svg" height="60" style="margin-right: 50px;">
				<img src="imgs/logo-thu.svg" height="60">
			</div>
		</div>
	</div>


</div>

<div class="footer"></div>